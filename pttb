#!/usr/bin/env python3
#
# Copyright (c) 2022 Pim van Pelt
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import sys
import logging
from config import Config
from incident import Incident
import command
from stats import Stats
import subprocess
import re, threading, queue

try:
    import argparse
except ImportError:
    print("ERROR: install argparse manually: sudo pip install argparse")
    sys.exit(2)

try:
    from telegram import Update
    from telegram import ParseMode
    from telegram.ext import Updater
    from telegram.ext import CommandHandler
    from telegram.bot import BotCommand
except ImportError:
    print("ERROR: install ptb manually: sudo pip install python-telegram-bot --upgrade")
    sys.exit(2)

class Pttb():
    def __init__(self, args):
        self.debug = args.debug
        self.verbose = args.verbose
        self.config = args.config
        self.file = args.file
        self.queue = queue.Queue()
        self.commands = []

        self.logger = self._setup_logger()
        self._setup_config()

    def _setup_config(self):
        Config.config = self.config
        if not Config.read():
            logging.error("Aborting")
            sys.exit(3)

    def add_command(self, command):
        self.commands.append(command())

    def _setup_logger(self):
        if self.debug:
            level = logging.DEBUG
        elif self.verbose:
            level = logging.INFO
        else:
            level = logging.CRITICAL + 1

        logging.basicConfig(format='[%(levelname)-8s] %(name)s - %(funcName)s: %(message)s', level=level)

    def _setup_bot(self):
        bot_commands = []
        for cmd in self.commands:
            bot_commands.append(BotCommand(str(cmd), cmd.get_short_description()))

        self.bot_queue = Updater(token=Config.token_get())

        self.bot_queue.dispatcher.bot.set_my_commands(bot_commands)
        for cmd in self.commands:
            self.bot_queue.dispatcher.add_handler(CommandHandler(str(cmd), cmd.handler))

        self.bot_queue.start_polling()
        #self.bot_queue.dispatcher.bot.send_message(chat_id=cfg.chatid_get(), text="Hello, I'm ready to gobble up some logs")

    def __enqueue_output(self, out, queue):
        for line in iter(out.readline, b''):
            self.queue.put(line.rstrip())
        out.close()

    def _main_tail(self):
        cmd = ['tail', '-F', '-q', '-n', '0'] + self.file
        f = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, bufsize = 1, close_fds = True, universal_newlines = True)
        thread = threading.Thread(target=self.__enqueue_output, args=(f.stdout, self.queue))
        thread.daemon = True
        thread.start()

        incidents = {}
        Stats.start()
        timeout = None
        while True:
            try:
                line = self.queue.get(block = True, timeout = timeout)
                Stats.loglines_read()
                logging.debug("line: %s" % line)

                for t in Config.trigger_list():
                    if re.search(t['regexp'], line):
                        logging.debug("trigger '%s' matched line '%s'" % (t['regexp'], line))
                        if not t['regexp'] in incidents:
                            i = Incident(t['regexp'], Config.get_duration_in_sec(t['duration']), t['message'])
                            logging.info("incident #%d created for trigger '%s'" % (i.getid(), t['regexp']))
                            incidents[t['regexp']] = i
                            Stats.incidents_created()
                        incidents[t['regexp']].feedlog(line)

            except queue.Empty:
                pass
            finally:
                timeout = None
                for k in list(incidents):
                    if not timeout:
                        timeout = incidents[k].duration
                    timeout = min(timeout, incidents[k].time_left())
                    if incidents[k].expired():
                        i = incidents[k].getid()
                        msg = incidents[k].render()
                        logging.debug("incident #%d expired, message '%s'" % (i, repr(msg)))

                        silence = False
                        for s in Config.silence_list():
                            if re.search(s['regexp'], msg):
                                logging.debug("silence '%s' matched message for incident #%d" % (s['regexp'], i))
                                silence = True
                        if silence:
                            logging.warning("silencing notification for incident #%d" % i)
                            Stats.incidents_silenced()
                        else:
                            logging.info("sending notification for incident #%d" % i)
                            self.bot_queue.dispatcher.bot.send_message(chat_id=Config.chatid_get(), text=msg, parse_mode=ParseMode.HTML)
                            Stats.incidents_sent()

                        del incidents[k]
                logging.debug("Timeout: {}".format(timeout))
        return

    def run(self):
        self._setup_bot()
        self._main_tail()

def main():
    parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('-v', dest='verbose', action='store_true', help="""Enable verbosity, default False""")
    parser.add_argument('-d', dest='debug', action='store_true', help="""Enable debug, default False""")
    parser.add_argument('-c', '--config', dest='config', default="/etc/pttb/pttb.yaml", type=str, 
            help="""Location of the YAML config file, default /etc/pttb/pttb.yaml""")
    parser.add_argument('--file', "-f", dest='file', nargs='+', required=True, type=str, help="""Logfile(s) to perform tail on""")

    args = parser.parse_args()

    pttb = Pttb(args)
    pttb.add_command(command.CommandTrigger)
    pttb.add_command(command.CommandStats)
    pttb.add_command(command.CommandSilence)

    pttb.run()

    logging.info("Exiting successfully. A job well done!")
    sys.exit(0)

if __name__ == "__main__":
    main()

